#pragma once

//
// IOCTLs for controlling the driver.
//

#define ST_DEVICE_TYPE 0x8000

#define IOCTL_ST_INITIALIZE \
	CTL_CODE(ST_DEVICE_TYPE, 1, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_ST_DEQUEUE_EVENT \
	CTL_CODE(ST_DEVICE_TYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ST_REGISTER_PROCESSES \
	CTL_CODE(ST_DEVICE_TYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ST_REGISTER_IP_ADDRESSES \
	CTL_CODE(ST_DEVICE_TYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ST_GET_IP_ADDRESSES \
	CTL_CODE(ST_DEVICE_TYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ST_SET_CONFIGURATION \
	CTL_CODE(ST_DEVICE_TYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ST_GET_CONFIGURATION \
	CTL_CODE(ST_DEVICE_TYPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ST_CLEAR_CONFIGURATION \
	CTL_CODE(ST_DEVICE_TYPE, 8, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_ST_GET_STATE \
	CTL_CODE(ST_DEVICE_TYPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_ST_QUERY_PROCESS \
	CTL_CODE(ST_DEVICE_TYPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_ST_RESET:
//
// Use before attempting to unload the driver.
// Subsystems will be torn down, resources released etc.
//
// On success, the new state will be ST_DRIVER_STATE_STARTED.
// On error, the new state will be ST_DRIVER_STATE_ZOMBIE.
//
#define IOCTL_ST_RESET \
	CTL_CODE(ST_DEVICE_TYPE, 11, METHOD_NEITHER, FILE_ANY_ACCESS)
